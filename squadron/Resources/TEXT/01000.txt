--[["Facing + Seeking."By Jon Irons (jonirons@gmail.com)A script that lets players use guided projectiles against monsters and other players in netgames. Just mark the "Guided" flag of a projectile in a physics file.]]function init()	to={}; --[[ the conversion table ]]	to.pdeg = 360/512; --[[ converting monster degrees to player degrees ]]	to.wu = 1/1024; --[[ converting monster units to world units ]]	HORIZ = 10; --[[ degrees to left and right of player view to include as "targeting" ]]	VERT = 45; --[[ vertical version of above. unused. ]]endfunction idle()	for a=0, MAXIMUM_MONSTERS_PER_MAP-1, 1 do --[[ loop through all monsters ]]		if (monster_index_valid(a)) then --[[ safety check ]]			if (monster_to_player(a)) then --[[ if monster is a player, then ... ]]				local facing_table = {}; --[[create a table for monster that he is facing; ]]				for b=0, MAXIMUM_MONSTERS_PER_MAP-1, 1 do --[[ loop through monsters again; ]]					if (a ~= b and monster_index_valid(b)) then --[[ if second monster isn't equal to the first and is valid ... ]]						if (is_monster_facing(a, b)) then --[[ if monster a is facing monster b ... ]]							facing_table[table.getn(facing_table) + 1] = b; --[[ add monster b to the facing table ]]						end					end				end				if (facing_table[1]) then --[[ if monster a is facing at least one other monster ... ]]					local most_close = closest_monster_to(a, facing_table); --[[ find closest out of all of them; ]]					for c=0, MAXIMUM_PROJECTILES_PER_MAP-1, 1 do --[[ loop through all projectiles; ]]						if (projectile_index_valid(c) and get_projectile_owner(c) == a) then --[[if proj. is valid and monster a owns it ... ]]							if (monster_index_valid(most_close)) then --[[ if closest monster index is still valid ... ]]								local player = monster_to_player(most_close); --[[ see if that monster is a player; ]]								if (player and get_life(player) >= 0 and get_projectile_target(c) ~= most_close) then --[[ if it is a player and he is still alive and the projectile isn't already targeting him ... ]]									set_projectile_target(c, most_close); --[[ make projectile c target him; ]]									--[[ NOTE: the following if/else is neccessary										in order to make sure a monster is still										alive while being targetted. If he isn't										alive but gets targetted, the game will										crash. Checks for monster or player are										made to determine how to find vitality. ]]									elseif (get_monster_vitality(most_close) >= 0 and get_projectile_target(c) ~= most_close) then --[[ if closest monster is not a player, etc ... ]]									set_projectile_target(c, most_close); --[[ make projectile target that monster; ]]								end							end						end					end				else --[[ if there are no monsters that a is facing ... ]]					for c=0, MAXIMUM_PROJECTILES_PER_MAP-1, 1 do --[[ loop through projectiles ]]						if (projectile_index_valid(c) and get_projectile_owner(c) == a) then --[[ if projectile has a target and is owned by a ... ]]							if (get_projectile_target(c)) then --[[ if projectile has a target already ... ]]								set_projectile_target(c, nil); --[[ make projectile target no one; ]]							end						end					end				end			end		end	endendfunction is_monster_facing(m1, m2) --[["m1" must be a player's monster index for now]]	local x1, y1, z1 = get_monster_position(m1); --[[ position data for monster 1 ]]	local yaw1, pitch1 = get_player_angle(monster_to_player(m1)); --[[ view data for monster 1 ]]	local x2, y2, z2 = get_monster_position(m2); --[[ position data for monster 2 ]]	local yaw2, pitch2 = get_monster_facing(m2); --[[ view data for monster 2 ]]	local distance = to.wu * math.sqrt((x1 - x2)^2 + (y1 - y2)^2); --[[ standard 2D distance formula ]]	local x = -1 * to.wu * (x2 - x1); --[[ convert x to negative WU of x2 - x1 ]]	local y = to.wu * (y2 - y1); --[[ positive version of above for y2 and y1 ]]	local m1angle = yaw1; --[[ renaming yaw ]]	local m2angle =  math.deg(math.atan2(y, x)); --[[ find degree version of atan2 between y and x ]]	m2angle = math.abs(m2angle - 180); --[[ making m2angle always >= 0 ]]	if (true) then --[[ why is this here? ]]		if (angle_distance(m1angle, m2angle) <= HORIZ) then --[[ if angle falls within HORIZ degree range ... ]]			return true; --[[ monster 1 is facing monster 2 ]]		else --[[ otherwise ... ]]			return false; --[[ monster 1 is not facing monster 2 ]]		end	endendfunction closest_monster_to(monster, monster_list) --[[Input is the monster in question and a table of monster indices]]	local ggg;	local dist1;	local cdist = 999999999;	cindex = monster;	local mindex = nil;	for ggg = 1, table.getn(monster_list), 1 do		local dude = monster_list[ggg];		if (monster_index_valid(dude) and dude ~= monster) then			local x1, y1, z1 = get_monster_position(monster);			local x2, y2, z2 = get_monster_position(dude);			dist1 = math.sqrt((x1 - x2)^2 + (y1 - y2)^2);			if (dist1 < cdist) then				cdist = dist1;				cindex = dude;			end		end	end	return cindex;endfunction monster_to_player(mon)	local h = nil;	for i=0, number_of_players()-1, 1 do		if (player_to_monster_index(i) == mon and monster_index_valid(mon)) then			h = i;		end	end	return h;endfunction angle_distance(angle1, angle2) --[[code by Solra Bizna]] --[[ Normalize the angles. ]] while angle1 < 0 do angle1 = angle1 + 360 end while angle1 >= 360 do angle1 = angle1 - 360 end while angle2 < 0 do angle2 = angle2 + 360 end while angle2 >= 360 do angle2 = angle2 - 360 end --[[ Subtract the angles. ]] return math.abs(angle1 - angle2)end