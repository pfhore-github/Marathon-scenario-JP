Triggers = {}

function checkMonsters()
	local livingPfhor = 0 -- see how many pfhor/wasps/lookers/drones we've got left
	local livingJuggernauts = 0 -- see how many juggernauts we've got left
	for m in Monsters() do
		if m.type == "minor fighter" or m.type == "major fighter" or m.type == "minor projectile fighter" or m.type == "major projectile fighter"
		or m.type == "minor drone" or m.type == "major drone" or m.type == "big minor drone" or m.type == "big major drone"
		or m.type == "major tick" or m.type == "kamikaze tick" or m.type == "minor hunter" or m.type == "major hunter" or m.type == "mother of all hunters"
		or m.type == "minor trooper" or m.type == "major trooper" or m.type == "minor enforcer" or m.type == "major enforcer" then
			livingPfhor = livingPfhor + 1
		elseif m.type == "water yeti" or m.type == "lava yeti" then
			livingJuggernauts = livingJuggernauts + 1
		end
	end
	--[[if Game.ticks % 900 == 0 then
		Players.print(livingPfhor .. " Pfhor & " .. livingJuggernauts .. " Juggernauts") -- print number of living Pfhor every half-minute; debug feature
	end--]]
	if livingJuggernauts == 0 and livingPfhor <= Global:exterminationlimit() then
		return true
	else
		return false
	end
end

function Triggers.got_item(type, player)
	Global:got_item(type, player)
end

function Triggers.monster_damaged(monster, aggressor_monster, damage_type, damage_amount, projectile)
	Global:monster_damaged(monster, aggressor_monster, damage_type, damage_amount, projectile)
end

function Triggers.player_damaged(victim, aggressor_player, aggressor_monster, damage_type, damage_amount, projectile)
	Global:player_damaged(victim, aggressor_player, aggressor_monster, damage_type, damage_amount, projectile)
end

function Triggers.player_killed(player, aggressor_player, action, projectile)
	Global:player_killed(player, aggressor_player, action, projectile)
end

function Triggers.player_revived(p)
	Global:player_revived(p, 7, 0, 0, 0, 0, 0, 150)
end

function Triggers.init(restoring)
	Global:initialize(restoring, 7, 0, 0, 0, 0, 0, 150)
	Level.stash["names"] = "physics1"

	if Level.stash["FAIL"] == "TRUE" or not restoring then
		Global:ch2_rebellion(restoring)
	end

	Global:goals()
end

function Triggers.idle()
	for p in Players() do
		Global:map_overlays(p)
		if p.z > 18 and not p._teleport then -- players will get stuck if they somehow grenade jump to top of central platform, so get them out
			p:teleport(Level._goal[42])
			p._teleport = true -- tell the game Lua is teleporting the player
		elseif p.z < 18 and p._teleport then
			p._teleport = false -- they must've completed their teleportation (or at least Lua isn't teleporting them)
		end
		if #Players > 1 then
			Global:checkrevival(p)
		end
		Global:loadfailure_player(p)
	end
	if Tags[1].active and Tags[3].active and Tags[4].active and Tags[5].active then
		if not Tags[2].active then
			Tags[2].active = true -- activate tag 2 if tags 1, 3, 4, and 5 are active
		end
		if Game.ticks % 15 == 0 and Tags[6].active and not Tags[7].active then
			-- no sense running this nonsense every tick; only check it if the rest of the mission is done, and only twice a second
			if checkMonsters() then -- check if the extermination requirements are complete
				Tags[7].active = true -- sets an invisible platform to active, which activates the final repair requirement
			end
		end
	end
end

function Triggers.cleanup()
	Global:cleanup()
end